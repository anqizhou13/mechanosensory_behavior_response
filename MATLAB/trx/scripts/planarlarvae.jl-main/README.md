# PlanarLarvae.jl

[![Build Status](https://gitlab.pasteur.fr/Nyx/PlanarLarvae.jl/badges/main/pipeline.svg)](https://gitlab.pasteur.fr/Nyx/PlanarLarvae.jl/pipelines)
[![Coverage](https://gitlab.pasteur.fr/Nyx/PlanarLarvae.jl/badges/main/coverage.svg)](https://gitlab.pasteur.fr/Nyx/PlanarLarvae.jl/commits/main)
[![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://gitlab.pasteur.fr/nyx/planarlarvae.jl/-/blob/main/LICENSE)
[![Documentation](https://img.shields.io/badge/docs-main-9cf.svg)](http://nyx.pages.pasteur.fr/planarlarvae.jl/)


This package features reading utilities for *spine* and *outline* files
generated by the [Choreography](https://github.com/Ichoran/choreography) (or *Chore.jar*) program,
for *table.csv* files generated by [FIMTrack](https://www.uni-muenster.de/Informatik.AGRisse/media/fim-media.html) v2,
and for *trx.mat* files generated by [JBM's automatic tagger](https://github.com/DecBayComp/Pipeline_action_analysis_t5_pasteur_janelia).

It provides basic datatypes for 2D spine- and outline-based descriptions of the larva,
and similarly features basic functionalities for discrete behavior tags with, notably,
support for JSON label files.

## Reading files

Records are read from *spine*/*outline* files and *trx.mat* files as named tuples
stored for every timestamp.

Records are specified as pairs of a name and a record type.
Record types can be any of `Spine`, `Outline` and `BehaviorTags`.
For example:

```julia
using PlanarLarvae, PlanarLarvae.Chore
using LazyArtifacts

sample_files = joinpath(artifact"chore_sample_output", "chore_sample_output")
runs = read_chore_files((:spine=>Spine, :outline=>Outline), sample_files)
```

`read_chore_files` returns a dictionary of runs (actually a single run),
that itself is a dictionary of larva with IDs as keys and timeseries of states
as values:

```@example
run, larvae = first(runs)
larva_id, track = first(larvae)
timestamp, spine_outline = first(track)
typeof(spine_outline)
```

Choreography files do not include behavior tags. These can be found in *trx.mat* files:

```@example
using PlanarLarvae.Trxmat

runs = read_trxmat((:spine=>Spine, :outline=>Outline, :tags=>BehaviorTags), artifact"sample_trxmat_file")

larvastate = first(eachstate(runs))
show(larvastate.tags)
```

FIMTrack files do not include behavior tags either, and outlines are not stored.
They are reconstructed from the spine points and associated radii:

```@example
using PlanarLarvae.FIMTrack

sample_file = joinpath(artifact"sample_fimtrack_tables", "collision_sample_table.csv")

tracks = read_fimtrack((:spine=>Spine, :outline=>Outline), sample_file; framerate=30)

example_track = tracks[1]
example_state = example_track[3.6]
```

### Higher-level interface

The [`Formats`](https://nyx.pages.pasteur.fr/planarlarvae.jl/#Top-level-module) module features a uniform interface for all file formats:
```@example
using PlanarLarvae.Formats

myfile = Formats.load(artifact"sample_labels_small/maggotuba.labels")

myfile isa Formats.JSONLabels
```
To get the data in the same datastructure as returned by `read_fimtrack` for example, *i.e.* a [`Datasets.Run`](https://nyx.pages.pasteur.fr/planarlarvae.jl/#PlanarLarvae.Datasets.Run) object:
```@example
tracks = getrun(myfile)

example_track = tracks[2]
example_state = example_track[9.831]
```
Alternatively, to get the data in the same Dict-based representation as with `read_trxmat` for example, *i.e.* a [`PlanarLarvae.LarvaBase.Larvae`](https://nyx.pages.pasteur.fr/planarlarvae.jl/#PlanarLarvae.LarvaBase.Larvae) object:
```@example
tracks = gettimeseries(myfile)

same_example_track = tracks[2]
timestamp, same_example_state = same_example_track[7]
timestamp == 9.831
```

In the above example, there are two distinctions between `example_state` and `same_example_state`. First, the data structures are not the same, although the discrete behavioral information in `example_state` is equal to that in `same_example_state`.

Second, `same_example_state` contains additional data. While `example_state` only contains behavior tags, `same_example_state` also contains spines and outlines.

This comes from the fact we have loaded a JSON label file (named *maggotuba.labels*). Label files only contain behavior tagging data and the `Datasets.Run` datatype is the preferred one for this type of data. `Datasets.Run` is also the native datatype for this type of files and, as a consequence, on loading the file, only local data were read.

However, label files also contain pointers to the corresponding tracking data files and, in the present case, spine and outline data originate from a pair of spine and outline files.
`PlanarLarvae.LarvaBase.Larvae` is the native datatype for this second type of data.
As a consequence, `gettimeseries` assumed we were interested in such data, loaded them from the associated tracking data files, and concatenated them together with the behavior tagging data into the desired data representation.

Calling `gettimeseries` in the first place, without calling `getrun` before, would have been noticeably slower than a call to `getrun`, here.

Read more about label files in the [*JSON files* section](#json_files).


## Geometries

Spines and outlines are [Meshes.jl](https://github.com/JuliaGeometry/Meshes.jl) geometries,
`Chain` and `PolyArea` objects respectively.
As a consequence, the [Meshes.jl](https://github.com/JuliaGeometry/Meshes.jl) interface is leveraged:

```@example
using Meshes

myoutline = outline([56.375, 20.625, 56.375, 20.75, 56.375, 20.875, 56.375, 21.0, 56.375, 21.125, 56.5, 21.125, 56.5, 21.25, 56.5, 21.375, 56.625, 21.375, 56.625, 21.375, 56.75, 21.375, 56.875, 21.375, 56.875, 21.375, 57.0, 21.25, 57.0, 21.25, 57.0, 21.125, 57.125, 21.125, 57.125, 21.0, 57.125, 20.875, 57.25, 20.875, 57.25, 20.75, 57.25, 20.625, 57.25, 20.5, 57.25, 20.375, 57.375, 20.375, 57.375, 20.25, 57.375, 20.125, 57.375, 20.0, 57.5, 20.0, 57.5, 19.875, 57.5, 19.75, 57.5, 19.625, 57.5, 19.5, 57.5, 19.375, 57.625, 19.375, 57.625, 19.25, 57.625, 19.125, 57.625, 19.0, 57.625, 18.875, 57.625, 18.75, 57.5, 18.75, 57.5, 18.75, 57.375, 18.75, 57.375, 18.750, 57.25, 18.875, 57.25, 18.875, 57.125, 18.875, 57.125, 19.0, 57.0, 19.0, 57.0, 19.125, 57.0, 19.25, 56.875, 19.25, 56.875, 19.375, 56.75, 19.375, 56.75, 19.5, 56.75, 19.625, 56.625, 19.625, 56.625, 19.75, 56.625, 19.875, 56.625, 20.0, 56.5, 20.0, 56.5, 20.125, 56.5, 20.25, 56.5, 20.375, 56.5, 20.5])
```
```@example
Meshes.centroid(myoutline)
```
```@example
boundingbox(myoutline)
```
```@example
area(myoutline)
```
```@example
PlanarLarvae.centroid(myoutline) âˆˆ myoutline
```
etc.

`PlanarLarvae` defines its own `centroid` function, hence the necessary prefixing.
The two functions equal in the case of an outline.
However, if a spine is available in the representation of a larva state,
then `PlanarLarvae.centroid` returns the midpoint of the spine, which is a departure
from the geometric-only `Meshes.centroid`.

## Behavior tags

Behavior tags are loaded as `BehaviorTags` objects that implement the `AbstractSet` interface.

A subset of the available behavior tags can be loaded from a `trx.mat` file passing an instanciated `BehaviorTags` as specification:
```@example
read_trxmat((:tags=>BehaviorTags([:run, :cast, :hunch, :back, :roll]),), artifact"sample_trxmat_file");
```

## JSON files

Time series of behavior tags are stored in *json* files as in the following example, with parts of the file manually escaped using `[...]`:

```
{
  "metadata": {
    "id": "20140918_170215",
    "tracker": "t15",
    "genotype": "GMR_SS02113",
    "effector": "UAS_Chrimson_Venus_X_0070",
    "protocol": "r_LED100_30s2x15s30s#n#n#n@100",
    "date_time": "20140918_170215",
    "filename": "[...].outline"
  },
  "units": {
    "t": "s"
  },
  "labels": {
    "names": ["run","bend","stop","hunch","back","roll"],
    "colors": ["#000000","#ff0000","#00ff00","#0000ff","#00ffff","#ffff00"]
  },
  "dependencies": [
    {
      "filename": "[...].spine",
      "sha1": "d5ac8809357ee28b1d87ef030910c5517ef53231"
    },
    {
      "filename": "[...].outline",
      "sha1": "4aa067203bd6471f0dcdd21490731865e83e7447"
    }
  ],
  "data": [
    {
      "id": "2",
      "t": [9.389,9.468,[...]],
      "labels": [1,1,[...]]
    },
    [...]
  ]
}
```

The `metadata`->`id` element gives a text identifier for the run/assay. Appart from this `id` element, none of the above-mentioned elements in object `metadata` is standard.

The `data` array lists the different moving objects (larvae) with their `id` (as a string) and time series of timestamps (float array `t`) and associated label specifications (array `labels`).

The top-level `labels` element can be an object, with the different label names listed in child element `names`. Alternatively, the top-level `labels` element can be an array that lists label names just like `labels`->`names` does in the above example.
The simpler array form is preferred for element `labels` when no additional information (such as `colors`) needs to be stored.

The `labels` elements in `data` are arrays with as many elements as in sibling `t`. Each element in `labels` can be a name (string) or a list of names (possibly empty array of strings).

Alternatively, labels can be integer-encoded so that each element in `labels` is either an index (integer) or indices (possibly empty array of integers). Indices point to array elements in the top-level `labels` or `labels`->`names` array. Encoded labels start from index `1`. In the above example, `1` refers to `"run"`, `2` to `"bend"`, etc.

This format is inspired by the [WCON](https://github.com/openworm/tracker-commons/blob/master/discuss/Formats.md#json-as-a-candidate-format=) proposal.
Such a file can be made WCON-compliant prefixing occurences of `labels`, `secondarylabels` and `dependencies` by `@`. In addition, `x` and `y` should be added to `units` (with associated text units) and to every objects in `data` (with associated numeric data).

### Additions

Common fields in the `metadata` object are `software`->`tagger` and `camera`->(`framerate`, `pixelsize`).

Since LarvaTagger==0.10, LarvaTagger.jl relies on the presence or absence of a `metadata`->`software`->`tagger` object in the file to decide whether the tagging was automatic or manual respectively.

Since PlanarLarvae==0.8 and LarvaTagger==0.10, an array-typed `secondarylabels` top-level element can be added along with `labels`. While the labels listed in the `labels` object are considered as primary tags, the `secondarylabels` array lists secondary tags that are expected to be used solely in combination with primary tags.

In encoded labels, secondary labels are indexed like if they were listed in the same array as primary labels, but immediately after.
For example, with line `"secondarylabels": ["edited"],` added to the above example, secondary label `"edited"` would be indexed `7`.

The first secondary tag introduced by LarvaTagger.jl is `"edited"` and is used to mark the associated primary tag as manually assigned, as opposed to automatically assigned (primary) tags. This secondary tag only appears in files where both manually and automatically assigned tags are present.

